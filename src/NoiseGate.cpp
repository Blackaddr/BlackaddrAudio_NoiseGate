/*
 * Company: Blackaddr Audio
 * Effect Name: Noise Gate
 * Description: A simple noise gate wtih controllable threshold, opening and closing times.
 *
 * This file was auto-generated by Aviate Audio Effect Creator for the Multiverse.
 */
#include <cmath>
#include "sysPlatform/SysTimer.h"
#include "Aviate/EfxPrint.h"
#include "NoiseGate.h"

using namespace Aviate;

namespace BlackaddrAudio_NoiseGate {

constexpr unsigned CALIB_MAX_TIME_SECONDS = 5;

NoiseGate::NoiseGate()
: AudioStream(NUM_INPUTS, m_inputQueueArray)
{

}

NoiseGate::~NoiseGate()
{

}

void NoiseGate::gateReset()
{
    // Gate reset
    _isOpen = true;
    gateFullyOpen = true;
    averageInputLinearAbs = 0.0003f;  // approximately -70 dB
}

void NoiseGate::update(void)
{
    audio_block_t *inputAudioBlock = receiveWritable(); // get the next block of input samples
    inputAudioBlock = m_basicInputCheck(inputAudioBlock, 0); // check for disable mode, bypass, or invalid inputs. Transmit to channel 0 in bypass

    if (!inputAudioBlock) {  // EFX level bypass
        // Gate reset
        gateReset();
        //sendValueReport(Gate_e, 0);  // The light is off in bypass
        //sendValueReport(InputLevel_e, -70.0f);
        sendReports(0, -70.0f);
        return;
    } // no further processing for this update() call

    // You must call m_updateInputPeak() before processing the audio
    m_updateInputPeak(inputAudioBlock);

    ///////////////////////////////////
    // START OF NOISE GATE PROCESSING
    ///////////////////////////////////
    float inputBlock[AUDIO_SAMPLES_PER_BLOCK];
    float blockGain[AUDIO_SAMPLES_PER_BLOCK];
    arm_q15_to_float((q15_t *)inputAudioBlock->data, inputBlock, AUDIO_SAMPLES_PER_BLOCK);

    if (m_calibrateEnabled) {
        for (unsigned idx=0; idx < AUDIO_SAMPLES_PER_BLOCK; idx++) {
            m_dcValueSum += inputBlock[idx];
        }
        m_dcValueCount += AUDIO_SAMPLES_PER_BLOCK;
    }

    if (m_dcfilterenable) {
        for (unsigned idx=0; idx < AUDIO_SAMPLES_PER_BLOCK; idx++) {
            inputBlock[idx] -= m_dcValue;
        }
    }

    // calculate the desired gain
    calcGain(inputBlock, blockGain, AUDIO_SAMPLES_PER_BLOCK);
    // smooth the "blocky" gain block
    calcSmoothedGain(blockGain, AUDIO_SAMPLES_PER_BLOCK);

    // multiply it to the input singal
    gateFullyOpen = false;
    for (unsigned idx=0; idx < AUDIO_SAMPLES_PER_BLOCK; idx++) {
        inputBlock[idx] *= (blockGain[idx] * m_volume);
        if (blockGain[idx] >= 0.3f) { gateFullyOpen = true; }
        //efxLogger.printf("blockgain[%d]: %f\n", idx, blockGain[idx]);
    }

    arm_float_to_q15 (inputBlock, inputAudioBlock->data, AUDIO_SAMPLES_PER_BLOCK);

    m_updateOutputPeak(inputAudioBlock); // you must call m_upateOutputPeak() at the end of update() before transmit
    transmit(inputAudioBlock);
    release(inputAudioBlock);

    //sendValueReport(Gate_e, !gateFullyOpen);  // The light is off when it's open, on when closed (muted)
    //sendValueReport(InputLevel_e, 20.0f * log10Fast(averageInputLinearAbs));
    sendReports(!gateFullyOpen, 20.0f * log10Fast(averageInputLinearAbs));

}

void NoiseGate::sendReports(float gate, float inputLevel)
{
    constexpr unsigned MIN_TIME_BETWEEN_REPORTS_MS = 33;  // about 30 reports per second
    static unsigned lastReport = 0;

    unsigned currentTime = SysPlatform::SysTimer::millis();
    unsigned timeSinceLastReport = currentTime - lastReport;

    if (timeSinceLastReport < MIN_TIME_BETWEEN_REPORTS_MS) { return; }  // drop the report

    sendValueReport(Gate_e, gate);
    sendValueReport(InputLevel_e, inputLevel);
    lastReport = currentTime;
}

void NoiseGate::volume(float value)
{
    float volDbValue = -40.0f + (value * 50.0f);  // remap the normalized value to represent -40dB to +10dB
    volumeDb(volDbValue);  // AudioEffectWrapper has built-in volume function in dB
}

void NoiseGate::dcfilter(float value)
{
    if (!m_calibrateEnabled && (value != 0)) {  // calib not enabled and button pushed
        m_calibrateEnabled = true;
        m_dcValueSum = 0.0f;
        m_dcValueCount = 0;
    }
    else if (m_calibrateEnabled && (value == 0)) { // calib is enabled and button released
        m_calibrateEnabled = false;
        if ((float)m_dcValueCount < (AUDIO_SAMPLE_RATE_HZ*0.5f)) {  // if it's held for les than 500 ms, do not use the results
            m_dcValueSum   = 0.0f;
            m_dcValueCount = 0;
            m_dcValue      = 0.0f; 
        } else {
            if (m_dcValueCount > 0) {
                m_dcValue = m_dcValueSum / static_cast<float>(m_dcValueCount);
            } else {
                m_dcValue = 0.0f;
            }
            
        }
    }
}

void NoiseGate::dcfilterenable(float value)
{
    m_dcfilterenable = value;
}

void NoiseGate::threshold(float value)
{
    m_threshold = value;
    // perform any necessary conversion to user variables, validation, etc.
    float valueDB = getUserParamValue(Threshold_e, value);  // convert to dB

    //linearThreshold = std::pow10f(valueDB / 20.0f);
    linearThreshold = powf(10, valueDB / 20.0f);

    efxLogger.printf("threshold change: normalized value: %f  dB value: %f  linear:%f\n", value, valueDB, linearThreshold);
}

void NoiseGate::attackms(float value)
{
    m_attackms = value;
    float timeSec = getUserParamValue(Attackms_e,value) / 1000.0f;
    efxLogger.printf("attackSec: %f\n", timeSec);
    openingTimeConst = std::exp(-1.0 / ((double)timeSec * (double)AUDIO_SAMPLE_RATE_HZ));
}

void NoiseGate::holdms(float value)
{
    m_holdms = value;
    float timeSec = getUserParamValue(Holdms_e,value) / 1000.0f;
    efxLogger.printf("holdSec: %f\n", timeSec);
    holdTimeNumSamples = timeSec * AUDIO_SAMPLE_RATE_HZ;
}

void NoiseGate::releasems(float value)
{
    m_releasems = value;
    float timeSec = getUserParamValue(Releasems_e,value) / 1000.0f;
    efxLogger.printf("releaseSec: %f\n", timeSec);
    closingTimeConst = std::exp(-1.0 / ((double)timeSec * (double)AUDIO_SAMPLE_RATE));
}

void NoiseGate::gate(float value)
{
    // this is an LED Monitor control, we ignore any incoming requests to set this parameter
}

void NoiseGate::inputlevel(float value)
{
    // this is a value monitor control, we ignore any incoming requests to set this parameter
}

void NoiseGate::calcGain(float *input, float *gainBlock, unsigned numSamples)
{
    _isOpen = false;
    float inputSum = 0.0f;
    for (unsigned i = 0; i < numSamples; i++)
    {
        // take absolute value and compare it to the set threshold
        float absInput = std::abs(input[i]);
        inputSum += absInput;
        bool isAboveThres = absInput > linearThreshold;
        _isOpen |= isAboveThres;
        // if above the threshold set volume to 1 otherwise to 0, we did not account for holdtime
        gainBlock[i] = isAboveThres ? 1 : 0;

        // if we are falling and are above the threshold, the level is not falling
        if (falling & isAboveThres)
        {
            falling = false;
        }
        // if we have a falling signal
        if (falling || lastGainBlockValue > gainBlock[i])
        {
            // check whether the hold time is not reached
            if (counter < holdTimeNumSamples)
            {
                // signal is (still) falling
                falling = true;
                counter++;
                gainBlock[i] = 1.0f;
            }
            // otherwise the signal is already muted due to the line: "gainBlock->data[i] = isAboveThres ? 1 : 0;"
        }
        // note the last gain value, so we can compare it if the signal is falling in the next sample
        lastGainBlockValue = gainBlock[i];
    }
    // Calculated the new average input level and perform 1st order filtering with a INPUT_LEVEL_ALPHA_FACTOR
    averageInputLinearAbs = (INPUT_LEVEL_ALPHA_FACTOR * (inputSum / static_cast<float>(numSamples))) + (1.0f - INPUT_LEVEL_ALPHA_FACTOR) * averageInputLinearAbs;
}

void NoiseGate::calcSmoothedGain(float *gain_block, unsigned numSamples)
{
    float32_t gain;
    float32_t one_minus_opening_const = 1.0f - openingTimeConst;
    float32_t one_minus_closing_const = 1.0f - closingTimeConst;
    for (unsigned i = 0; i < numSamples; i++)
    {
        gain = gain_block[i];

        // smooth the gain using the opening or closing constants
        if (gain > prev_gain_dB)
        { // are we in the opening phase?
            gain_block[i] = openingTimeConst * prev_gain_dB + one_minus_opening_const * gain;
        }
        else
        { // or, we're in the closing phase
            gain_block[i] = closingTimeConst * prev_gain_dB + one_minus_closing_const * gain;
        }

        // save value for the next time through this loop
        prev_gain_dB = gain_block[i];
    }
    return; // the output here is gain_block
}

}
